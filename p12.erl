-module(p12).

-export([answer/0, triangle_iterator/0]).

%% The sequence of triangle numbers is generated by adding the natural numbers.
%% So the 7^(th) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
%% 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
%% Let us list the factors of the first seven triangle numbers:
%%   1: 1
%%   3: 1, 3
%%   6: 1, 2, 3, 6
%%  10: 1, 2, 5, 10
%%  15: 1, 3, 5, 15
%%  21: 1, 3, 7, 21
%%  28: 1, 2, 4, 7, 14, 28
%% We can see that 28 is the first triangle number to have over five divisors.
%% What is the value of the first triangle number to have over five hundred divisors?

answer() ->
    TriNums = triangle_iterator(),
    find_factors(TriNums(), 501).

find_factors([Tri | Next], NumFactors) ->
    FoundFactors = count_factors(Tri),
    case FoundFactors < NumFactors of
        true ->  find_factors(Next(), NumFactors);
        _Else -> Tri
    end.

count_factors(N) ->
    CandidatePrimes = primes:queue(round(math:sqrt(N))),
    PrimeFactors = [ X || X <- CandidatePrimes, N rem X =:= 0 ],
    Combos = combos(PrimeFactors, N, 0, []),
    lists:foldl(fun({_Prime, C}, Acc) -> Acc*(C+1) end, 1, Combos).

%% X is a prime factor, N is what's left, C is the count for X, L is the prime factor and count of exponents
%% returns a list of primes and their exponents of the factorization
%% so if 108 factors to 2^2 * 3^3, first arg will be [2, 3] and return [{2,2},{3,3}]
combos([], _N, _C, L) -> L;
combos([X | _T], 1, C, L) ->
    [{X, C} | L];
combos([X | T], N, C, L) when N rem X =:= 0 ->
    combos([X | T], N div X, C+1, L);
combos([X | T], N, C, L) ->
    combos(T, N, 0, [{X, C} | L]).

triangle_iterator() ->
    fun() -> tri_iter(2, 1) end.
% N is the next Tri#< whereas Tri is the current Tri#
tri_iter(N, Tri) ->
    [ Tri | fun() -> tri_iter(N+1, N+Tri) end ].
